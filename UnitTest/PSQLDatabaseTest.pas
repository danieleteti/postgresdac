unit PSQLDatabaseTest;
{$I PSQLDAC.inc}
{$IFDEF DUNITX}
  {$M+}
{$ENDIF}
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
PSQLAccess, PSQLDbTables, PSQLTypes, SysUtils, Classes
  {$IFNDEF DUNITX}
  , TestFramework, Db, Windows, ExtCtrls, Controls, DbCommon,
  {$IFNDEF DELPHI_5}Variants,{$ENDIF} Graphics, StdVCL, TestExtensions,
  Forms, PSQLConnFrm
  {$ELSE}
    ,DUnitX.TestFramework
  {$ENDIF};

type

  {$IFNDEF DUNITX}
  //Setup decorator
  TDbSetup = class(TTestSetup)
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  end;
  {$ENDIF}

  // Test methods for class TPSQLDatabase
  {$IFNDEF DUNITX}[TestFixture]{$ENDIF}
  TestTPSQLDatabase = class({$IFNDEF DUNITX}TTestCase{$ELSE}TObject{$ENDIF})
  published
    procedure HookUp;
    procedure TestPlainConnInfoConnect;
    procedure TestExecute;
    procedure TestGetBackendPID;
    procedure TestSelectString;
    procedure TestSelectString1;
    procedure TestSelectStringDef;
    procedure TestSelectStringDef1;
    procedure TestSelectStrings;
    procedure TestSelectStrings1;
    procedure TestCommit;
    procedure TestGetCharsets;
    procedure TestGetDatabases;
    procedure TestGetSchemaNames;
    procedure TestGetStoredProcNames;
    procedure TestGetTableNames;
    procedure TestGetTablespaces;
    procedure TestGetUserNames;
    procedure TestReset;
    procedure TestRollback;
    procedure TestPing;
    procedure TestPingEx;
    procedure TestIsThreadSafe;
    procedure TestSSLConnect;

    {$IFDEF DUNITX}
    [SetupFixture]
    procedure SetupFixture;
    {$ENDIF}
  end;

  var
    FPSQLDatabase: TPSQLDatabase;

implementation

uses TestHelper, MainF;

procedure TestTPSQLDatabase.HookUp;
begin
  DACIsTrue(True);
end;

procedure TestTPSQLDatabase.TestExecute;
var
  ReturnValue: Integer;
  SQL: string;
begin
  SQL := 'SELECT version()';
  ReturnValue := FPSQLDatabase.Execute(SQL);
  DACIsTrue(ReturnValue = 1);
end;

procedure TestTPSQLDatabase.TestGetBackendPID;
var
  ReturnValue: Cardinal;
begin
  ReturnValue := FPSQLDatabase.GetBackendPID;
  DACIsTrue(ReturnValue > InvalidOID);
end;

procedure TestTPSQLDatabase.TestSelectString;
var
  ReturnValue: string;
  aFieldName: string;
  IsOk: Boolean;
  aSQL: string;
begin
  aSQL := 'SELECT 12345 as column1';
  aFieldName := 'column1';
  ReturnValue := FPSQLDatabase.SelectString(aSQL, IsOk, aFieldName);
  DACIsTrue(IsOk);
  DACIsTrue('12345' = ReturnValue);
end;

procedure TestTPSQLDatabase.TestSelectString1;
var
  ReturnValue: string;
  aFieldNumber: Integer;
  IsOk: Boolean;
  aSQL: string;
begin
  aSQL := 'SELECT 12345 as column1';
  aFieldNumber := 0;
  ReturnValue := FPSQLDatabase.SelectString(aSQL, IsOk, aFieldNumber);
  DACIsTrue(IsOk);
  DACIsTrue('12345' = ReturnValue);
end;

procedure TestTPSQLDatabase.TestSelectStringDef;
var
  ReturnValue: string;
  aFieldName: string;
  aDefaultValue: string;
  aSQL: string;
begin
  aSQL := 'SELECT 12345 as column1';
  aFieldName := 'column1';
  ReturnValue := FPSQLDatabase.SelectStringDef(aSQL, aDefaultValue, aFieldName);
  DACIsTrue('12345' = ReturnValue);
  aSQL := 'SELECT 12345 as column1';
  aFieldName := 'WRONG_COL_NAME';
  aDefaultValue := 'MyDefaultValue';
  ReturnValue := FPSQLDatabase.SelectStringDef(aSQL, aDefaultValue, aFieldName);
  DACIsTrue(aDefaultValue = ReturnValue);
end;

procedure TestTPSQLDatabase.TestSelectStringDef1;
var
  ReturnValue: string;
  aFieldNumber: Integer;
  aDefaultValue: string;
  aSQL: string;
begin
  aSQL := 'SELECT 12345 as column1';
  aFieldNumber := 0;
  ReturnValue := FPSQLDatabase.SelectStringDef(aSQL, aDefaultValue, aFieldNumber);
  DACIsTrue('12345' = ReturnValue);
  aSQL := 'SELECT 12345 as column1';
  aFieldNumber := -1234214;
  aDefaultValue := 'MyDefaultValue';
  ReturnValue := FPSQLDatabase.SelectStringDef(aSQL, aDefaultValue, aFieldNumber);
  DACIsTrue(aDefaultValue = ReturnValue);
end;

procedure TestTPSQLDatabase.TestSelectStrings;
var
  aFieldName: string;
  aList: TStrings;
  aSQL: string;
begin
  aList := TStringList.Create;
  try
    aSQL := 'SELECT 1, g.s FROM generate_series(1,10) as g(s)';
    aFieldName := 's';
    FPSQLDatabase.SelectStrings(aSQL, aList, aFieldName);
    DACCheck(aList.Count = 10, 'SelectStrings by FieldName failed');
  finally
    {$IFNDEF NEXTGEN}
    aList.Free;
    {$ELSE}
    aList.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestSelectStrings1;
var
  aFieldNumber: Integer;
  aList: TStrings;
  aSQL: string;
begin
  aList := TStringList.Create;
  try
    aSQL := 'SELECT 1, g.s FROM generate_series(1,10) as g(s)';
    aFieldNumber := 1;
    FPSQLDatabase.SelectStrings(aSQL, aList, aFieldNumber);
    DACCheck(aList.Count = 10, 'SelectStrings by FieldNumber failed');
  finally
    {$IFNDEF NEXTGEN}
    aList.Free;
    {$ELSE}
    aList.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestSSLConnect;
var
  sslDB: TPSQLDatabase;
begin
  sslDB := TPSQLDatabase.Create(nil);
  try
    sslDB.Assign(FPSQLDatabase);
    sslDB.Close;
    sslDB.SSLMode := sslVerifyCA;
    sslDB.SSLCert := 'TestData\postgresql.crt';
    sslDB.SSLKey := 'TestData\postgresql.key';
    sslDB.SSLRootCert := 'TestData\root.crt';
    sslDB.Open;
    DACCheck(sslDB.Connected, 'SSL Connection failed');
  finally
    {$IFNDEF NEXTGEN}
    FreeAndNil(sslDB);
    {$ELSE}
    sslDB.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestCommit;
begin
  FPSQLDatabase.StartTransaction;
  DACCheck(FPSQLDatabase.TransactionStatus in [trstINTRANS, trstACTIVE], 'Failed to BEGIN transaction');
  FPSQLDatabase.Execute('CREATE TEMP TABLE foo()');
  FPSQLDatabase.Commit;
  DACCheck(FPSQLDatabase.TransactionStatus = trstIDLE, 'Failed to COMMIT transaction');
end;

procedure TestTPSQLDatabase.TestGetCharsets;
var
  aList: TStrings;
begin
  aList := TStringList.Create;
  try
    FPSQLDatabase.GetCharsets(aList);
    DACCheck(aList.Count > 0, 'GetCharsets failed');
  finally
    {$IFNDEF NEXTGEN}
    aList.Free;
    {$ELSE}
    aList.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestGetDatabases;
var
  aList: TStrings;
  Pattern: string;
begin
  aList := TStringList.Create;
  try
    Pattern := '%';
    FPSQLDatabase.GetDatabases(Pattern, aList);
    DACCheck(aList.Count > 0, 'GetDatabases failed');
  finally
    {$IFNDEF NEXTGEN}
    aList.Free;
    {$ELSE}
    aList.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestGetSchemaNames;
var
  List: TStrings;
  SystemSchemas: Boolean;
  Pattern: string;
  Count: integer;
begin
  List := TStringList.Create;
  try
    Pattern := '%';
    SystemSchemas := True;
    FPSQLDatabase.GetSchemaNames(Pattern, SystemSchemas, List);
    Count := List.Count;
    List.Clear;
    FPSQLDatabase.GetSchemaNames(Pattern, not SystemSchemas, List);
    DACCheck(List.Count <= Count, 'GetSchemaNames failed');
  finally
    {$IFNDEF NEXTGEN}
    List.Free;
    {$ELSE}
    List.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestGetStoredProcNames;
var
  aList: TStrings;
  Pattern: string;
begin
  aList := TStringList.Create;
  try
    Pattern := '%';
    FPSQLDatabase.GetStoredProcNames(Pattern, aList);
    DACCheck(aList.Count > 0, 'GetStoredProcNames failed');
  finally
    {$IFNDEF NEXTGEN}
    aList.Free;
    {$ELSE}
    aList.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestGetTableNames;
var
  List: TStrings;
  SystemTables: Boolean;
  Pattern: string;
  Count: integer;
begin
  List := TStringList.Create;
  try
    Pattern := '%';
    SystemTables := True;
    FPSQLDatabase.GetTableNames(Pattern, SystemTables, List);
    Count := List.Count;
    List.Clear;
    FPSQLDatabase.GetTableNames(Pattern, not SystemTables, List);
    DACCheck(List.Count <= Count, 'GetTableNames failed');
  finally
    {$IFNDEF NEXTGEN}
    List.Free;
    {$ELSE}
    List.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestGetTablespaces;
var
  aList: TStrings;
  Pattern: string;
begin
  aList := TStringList.Create;
  try
    Pattern := '%';
    FPSQLDatabase.GetTablespaces(Pattern, aList);
    DACCheck(aList.Count > 0, 'GetTablespaces failed');
  finally
    {$IFNDEF NEXTGEN}
    aList.Free;
    {$ELSE}
    aList.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestGetUserNames;
var
  aList: TStrings;
  Pattern: string;
begin
  aList := TStringList.Create;
  try
    Pattern := '%';
    FPSQLDatabase.GetUserNames(Pattern, aList);
    DACCheck(aList.Count > 0, 'GetUserNames failed');
  finally
    {$IFNDEF NEXTGEN}
    aList.Free;
    {$ELSE}
    aList.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestIsThreadSafe;
begin
  DACCheck(PSQLTypes.PQIsThreadSafe() = 1, 'Library loaded is thread unsafe');
end;

procedure TestTPSQLDatabase.TestPing;
begin
  DACCheck(FPSQLDatabase.Ping = pstOK, 'Ping failed');
end;

procedure TestTPSQLDatabase.TestPingEx;
var
  ConnParams: TStringList;
begin
  ConnParams := TStringList.Create;
  try
    ConnParams.Assign(FPSQLDatabase.Params);
    DACCheck(FPSQLDatabase.Ping() = pstOK, 'PingEx failed');
  finally
    {$IFNDEF NEXTGEN}
    ConnParams.Free;
    {$ELSE}
    ConnParams.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLDatabase.TestPlainConnInfoConnect;
var
  oldUseSingleLine: Boolean;
begin
  FPSQLDatabase.Close;
  oldUseSingleLine := FPSQLDatabase.UseSingleLineConnInfo;
  FPSQLDatabase.UseSingleLineConnInfo := True;
  try
  FPSQLDatabase.Open;
  DACCheck(FPSQLDatabase.Connected, 'Failed to connect using PQconnectdb');
  finally
    FPSQLDatabase.Close;
    FPSQLDatabase.UseSingleLineConnInfo := oldUseSingleLine;
    FPSQLDatabase.Open
  end;
end;

procedure TestTPSQLDatabase.TestReset;
begin
  FPSQLDatabase.Reset;
end;

procedure TestTPSQLDatabase.TestRollback;
begin
  FPSQLDatabase.StartTransaction;
  DACCheck(FPSQLDatabase.TransactionStatus in [trstINTRANS, trstACTIVE], 'Failed to BEGIN transaction');
  FPSQLDatabase.Execute('CREATE TEMP TABLE foo()');
  FPSQLDatabase.Rollback;
  DACCheck(FPSQLDatabase.TransactionStatus = trstIDLE, 'Failed to ROLLBACK transaction');
end;

{$IFNDEF DUNITX}
{ MainFormSetup }

procedure TDbSetup.SetUp;
begin
  inherited;
  SetUpTestDatabase(FPSQLDatabase, 'PSQLDatabaseTest.conf');
end;

procedure TDbSetup.TearDown;
begin
  inherited;
  FPSQLDatabase.Close;
  ComponentToFile(FPSQLDatabase, 'PSQLDatabaseTest.conf');
  FPSQLDatabase.Free;
end;
{$ENDIF}

{$IFDEF DUNITX}
procedure TestTPSQLDatabase.SetupFixture;
begin
  FPSQLDatabase := MainForm.Database;
end;
{$ENDIF}

initialization
{$IFNDEF DUNITX}
  //PaGo: Register any test cases with setup decorator
  RegisterTest(TDbSetup.Create(TestTPSQLDatabase.Suite, 'Database Setup'));
{$ELSE}
  TDUnitX.RegisterTestFixture(TestTPSQLDatabase);
{$ENDIF}
  // Register any test cases with the test runner
  //RegisterTest(TestTPSQLDatabase.Suite);
end.

