unit PSQLErrorsTest;
{$IFDEF DUNITX}
  {$M+}
{$ENDIF}
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  PSQLTypes, Classes, SysUtils, PSQLDbTables
  {$IFNDEF DUNITX}
  ,TestFramework, Db, Windows, Math, PSQLAboutFrm, TestExtensions
  {$ELSE}
  , DUnitX.TestFramework, ioUtils
  {$ENDIF};

type
  {$IFNDEF DUNITX}
  //Setup decorator
  TDbSetup = class(TTestSetup)
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  end;
  {$ENDIF}

  // Test methods for class TPSQLErrors
  {$IFDEF DUNITX}[TestFixture]{$ENDIF}
  TestTPSQLErrors = class({$IFNDEF DUNITX}TTestCase{$ELSE}TObject{$ENDIF})
  published
    procedure TestFailedConnect;
    procedure TestSyntaxError;
    procedure TestConstraintViolation;
    {$IFDEF DUNITX}
    [SetupFixture]
    procedure SetupFixture;
    {$ENDIF}
  end;

var
  QryDb: TPSQLDatabase;
  FilePath: string;
  ErrorsFileName: string;

implementation

uses TestHelper{$IFDEF DUNITX}, MainF{$ENDIF};

procedure InternalSetUp;
begin
  QryDB.ErrorVerbosity := evVERBOSE;
end;

{$IFDEF DUNITX}
procedure TestTPSQLErrors.SetupFixture;
begin
  QryDb := MainForm.Database;
  InternalSetUp;
end;
{$ENDIF}

procedure TestTPSQLErrors.TestConstraintViolation;
begin
 if QryDB.ServerVersionAsInt < 090300 then Exit; //feature unsupported
 qryDB.Execute('CREATE TABLE IF NOT EXISTS aa (a int PRIMARY KEY);');
 try
   qryDB.Execute('INSERT INTO aa VALUES (1)');
   try
     qryDB.Execute('INSERT INTO aa VALUES (1)');
   except
     on E: EPSQLDatabaseError do
     begin
      DACCheck(E.ErrorConstraintName > '', 'Error constraint name is empty');
      DACCheck(E.ErrorTableName > '', 'Error table name is empty');
      Status(E.ErrorPrimary);
      Status(E.ErrorConstraintName);
     end;
   end;
 finally
   qryDB.Execute('DROP TABLE aa CASCADE')
 end;
end;

procedure TestTPSQLErrors.TestFailedConnect;
var D: TPSQLDatabase;
begin
  D := TPSQLDatabase.Create(nil);
  try
    D.Host := 'some.unreal.host';
    D.UserName := 'some unreal user';
    D.UserPassword := 'some wrong pwd';
    D.DatabaseName := 'some unexistent db';
    try
     D.Open;
    except
     on E: EPSQLDatabaseError do
     begin
       DACCheck(E.Message > '', 'Error message is empty');
       Status(E.Message);
     end;
    end;
  finally
    {$IFNDEF NEXTGEN}
    D.Free;
    {$ELSE}
    D.DisposeOf;
    {$ENDIF}
  end;
end;

procedure TestTPSQLErrors.TestSyntaxError;
begin
 try
   qryDb.Execute('SOMETHING STUPID');
 except
   on E: EPSQLDatabaseError do
   begin
    DACCheck(E.ErrorSeverity > '', 'Error severity is empty');
    DACCheck(E.ErrorSqlState > '', 'Error SQL state is empty');
    DACCheck(E.ErrorPrimary > '', 'Error primary message is empty');
   end;
 end;
end;

{$IFNDEF DUNITX}
{ TDbSetup }

procedure TDbSetup.SetUp;
begin
  inherited;
  SetUpTestDatabase(QryDB, 'PSQLErrors.conf');
  InternalSetUp;
end;

procedure TDbSetup.TearDown;
begin
  inherited;
  QryDB.Close;
  ComponentToFile(QryDB, 'PSQLErrors.conf');
  QryDB.Free;
end;
{$ENDIF}

initialization
 {$IFNDEF DUNITX}
  //PaGo: Register any test cases with setup decorator
  RegisterTest(TDbSetup.Create(TestTPSQLErrors.Suite, 'Database Setup'));
{$ELSE}
  TDUnitX.RegisterTestFixture(TestTPSQLErrors);
{$ENDIF}
  FilePath := {$IFDEF DUNITX}
                      TPath.GetDocumentsPath + PathDelim
                     {$ELSE}
                     'TestOut\'
                     {$ENDIF};
  ErrorsFileName := FilePath + 'TestErrorsToFile.backup';

end.

