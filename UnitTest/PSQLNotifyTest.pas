unit PSQLNotifyTest;
{$IFDEF DUNITX}
  {$M+}
{$ENDIF}
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  Classes, PSQLNotify, PSQLTypes, PSQLAccess, PSQLDbTables
  {$IFNDEF DUNITX}
  , TestFramework,
  TestExtensions
  {$ELSE}
  , DUnitX.TestFramework
  {$ENDIF};

type
  THandlerClass = class
    class procedure NotifyHandler(Sender: TObject; Event: string; ProcessID : Integer);
    class procedure NotifyHandlerEx(Sender: TObject; Channel: string; Payload: string; ProcessID : Integer);
  end;

  {$IFNDEF DUNITX}
  //Setup decorator
  TDbSetup = class(TTestSetup)
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  public
//    procedure NotifyHandler(Sender: TObject; Event: string; ProcessID : Integer);
//    procedure NotifyHandlerEx(Sender: TObject; Channel: string; Payload: string; ProcessID : Integer);
  end;
  {$ENDIF}

  // Test methods for class TPSQLNotify
  {$IFNDEF DUNITX}[TestFixture]{$ENDIF}
  TestTPSQLNotify = class({$IFNDEF DUNITX}TTestCase{$ELSE}TObject{$ENDIF})
  private
    FPSQLNotify: TPSQLNotify;
    procedure InternalSetUp;
    procedure InternalTearDown;
  public
    {$IFNDEF DUNITX}
    procedure SetUp; override;
    procedure TearDown; override;
    {$ELSE}
    [Setup]
    procedure SetUp;
    [TearDown]
    procedure TearDown;
    {$ENDIF}
  published
    procedure TestOpenNotify;
    procedure TestCloseNotify;
    procedure TestListenTo;
    procedure TestSendNotify;
    procedure TestSendNotify1;
    procedure TestUnlistenTo;
    procedure TestUnlistenAll;
    {$IFDEF DUNITX}
    [SetupFixture]
    procedure SetupFixture;
    [TearDownFixture]
    procedure TearDownFixture;
    {$ENDIF}
  end;

var
  NotifyDb: TPSQLDatabase;
  TestNotify: TPSQLNotify;
  MsgReceived, MsgReceivedEx: boolean;

implementation

uses TestHelper, SysUtils, MainF;

procedure TestTPSQLNotify.InternalSetUp;
begin
  TestNotify := TPSQLNotify.Create(nil);
  TestNotify.Database := NotifyDb;
  TestNotify.ListenList.CommaText := 'first,second,third,custom';
  TestNotify.OnNotify := THandlerClass.NotifyHandler;
  TestNotify.OnNotifyEx := THandlerClass.NotifyHandlerEx;
  TestNotify.Active := True;
  DACCheck(NotifyDB.ServerVersionAsInt > 090000, 'Server version less then 9.0 to test Payload functionality');
end;

procedure TestTPSQLNotify.InternalTearDown;
begin
  TestNotify.Free;
  if not MsgReceived then Status('Simple notify message lost');
  if not MsgReceivedEx then Status('Payload notify message lost');
end;

procedure TestTPSQLNotify.SetUp;
begin
  FPSQLNotify := TPSQLNotify.Create(nil);
  FPSQLNotify.Database := NotifyDb;
  FPSQLNotify.ListenList.CommaText := 'first,second,third';
end;

{$IFDEF DUNITX}
procedure TestTPSQLNotify.SetupFixture;
begin
  NotifyDb := MainForm.Database;
  InternalSetUp;
end;
procedure TestTPSQLNotify.TearDownFixture;
begin
  InternalTearDown;
end;
{$ENDIF}

procedure TestTPSQLNotify.TearDown;
begin
  FPSQLNotify.Free;
  FPSQLNotify := nil;
end;

procedure TestTPSQLNotify.TestOpenNotify;
begin
  FPSQLNotify.OpenNotify;
  DACCheck(FPSQLNotify.Active, 'Notify is not active');
end;

procedure TestTPSQLNotify.TestCloseNotify;
begin
  FPSQLNotify.CloseNotify;
  DACCheck(not FPSQLNotify.Active, 'Notify is active');
end;

procedure TestTPSQLNotify.TestListenTo;
var
  Event: string;
begin
  Event := 'custom';
  FPSQLNotify.OpenNotify();
  FPSQLNotify.ListenTo(Event);
  DACCheck(FPSQLNotify.ListenList.IndexOf(Event) > -1, 'ListenTo failed');
end;

procedure TestTPSQLNotify.TestSendNotify;
var
  Event: string;
begin
  Event := 'first';
  FPSQLNotify.OpenNotify();
  FPSQLNotify.SendNotify(Event);
end;

procedure TestTPSQLNotify.TestSendNotify1;
var
  Payload: string;
  Channel: string;
begin
  Channel := 'second';
  Payload := 'the second channel';
  FPSQLNotify.OpenNotify();
  FPSQLNotify.SendNotify(Channel, Payload);
end;

procedure TestTPSQLNotify.TestUnlistenTo;
var
  Event: string;
begin
  Event := 'third';
  FPSQLNotify.OpenNotify();
  FPSQLNotify.UnlistenTo(Event);
  DACCheck(FPSQLNotify.ListenList.IndexOf(Event) = -1, 'UnlistenTo doesn''t exclude event');
end;

procedure TestTPSQLNotify.TestUnlistenAll;
begin
  FPSQLNotify.OpenNotify();
  FPSQLNotify.UnlistenAll;
  DACCheck(FPSQLNotify.ListenList.Count = 0, 'UnlistenAll doesn''t clear events');
end;

{$IFNDEF DUNITX}
{ TDbSetup }

procedure TDbSetup.SetUp;
begin
  inherited;
  SetUpTestDatabase(NotifyDb, 'PSQLNotify.conf');
  InternalSetUp;
end;

procedure TDbSetup.TearDown;
begin
  inherited;
  NotifyDb.Close;
  ComponentToFile(NotifyDb, 'PSQLNotify.conf');
  NotifyDb.Free;
  InternalTearDown;
end;
{$ENDIF}

class procedure THandlerClass.NotifyHandler(Sender: TObject; Event: string;
  ProcessID: Integer);
begin
  if NotifyDb.GetBackendPID = ProcessID then //it's ours
    if not MsgReceived then
      MsgReceived := (Event = 'first');
end;

class procedure THandlerClass.NotifyHandlerEx(Sender: TObject; Channel,
  Payload: string; ProcessID: Integer);
begin
  if NotifyDb.GetBackendPID = ProcessID then //it's ours
   begin
    if not MsgReceived then
      MsgReceived := (Channel = 'first');
    if not MsgReceivedEx then
      MsgReceivedEx := (Channel = 'second') and (Payload = 'the second channel');
   end;
end;

initialization
 {$IFNDEF DUNITX}
  //PaGo: Register any test cases with setup decorator
  RegisterTest(TDbSetup.Create(TestTPSQLNotify.Suite, 'Database Setup'));
{$ELSE}
  TDUnitX.RegisterTestFixture(TestTPSQLNotify);
{$ENDIF}

end.

