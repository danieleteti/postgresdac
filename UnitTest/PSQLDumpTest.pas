unit PSQLDumpTest;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Db, PSQLDump, PSQLTypes, Classes, SysUtils, PSQLDbTables,
  Variants, Windows, Math, PSQLAboutFrm, TestExtensions;

type
  //Setup decorator
  TDbSetup = class(TTestSetup)
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  end;

  // Test methods for class TPSQLDump
  TestTPSQLDump = class(TTestCase)
  strict private
    FPSQLDump: TPSQLDump;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestDumpToStream;
    procedure TestDumpToStream1;
    procedure TestDumpToStream2;
    procedure TestDumpToFile;
    procedure TestDumpToFile1;
    //specific routines
    procedure TestDumpCompressed;
    procedure TestDumpTar;
    procedure TestDumpDirectory;
    procedure TestDumpPlain;
    procedure TestDumpPlainCompressed;
  end;

  // Test methods for class TPSQLRestore
  TestTPSQLRestore = class(TTestCase)
  strict private
    FPSQLRestore: TPSQLRestore;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestRestoreFromFile;
    procedure TestRestoreFromFile1;
  end;

var
  QryDb: TPSQLDatabase;
  DumpFileName: string = 'TestDumpToFile.backup';


implementation

uses TestHelper;

procedure TestTPSQLDump.SetUp;
begin
  FPSQLDump := TPSQLDump.Create(nil);
  FPSQLDump.Database := QryDb;
  FPSQLDump.Options := [doVerbose];
end;

procedure TestTPSQLDump.TearDown;
begin
  FPSQLDump.Free;
  FPSQLDump := nil;
end;

procedure TestTPSQLDump.TestDumpToStream;
var
  Stream: TStream;
begin
  Stream := TMemoryStream.Create;
  try
    FPSQLDump.DumpToStream(Stream);
    Check(Stream.Size > 0, 'Dump stream empty');
  finally
    Stream.Free;
  end;
end;

procedure TestTPSQLDump.TestDumpToStream1;
var
  Log: TStrings;
  Stream: TStream;
begin
  Stream := TMemoryStream.Create;
  try
    Log := TStringList.Create;
    try
      FPSQLDump.DumpToStream(Stream, Log);
      Check(Stream.Size > 0, 'Dump stream empty');
      Check(Log.Count > 0, 'Dump log empty');
    finally
      Log.Free;
    end;
  finally
    Stream.Free;
  end;
end;

procedure TestTPSQLDump.TestDumpToStream2;
var
  LogFileName: string;
  Stream: TStream;
begin
  Stream := TMemoryStream.Create;
  try
    LogFileName := 'TestDumpToStream2.log';
    try
      FPSQLDump.DumpToStream(Stream, LogFileName);
      Check(Stream.Size > 0, 'Dump stream empty');
      Check(FileExists(LogFileName), 'Log file empty');
    finally
      SysUtils.DeleteFile(LogFileName);
    end;
  finally
    Stream.Free;
  end;
end;

procedure TestTPSQLDump.TestDumpCompressed;
begin
  FPSQLDump.DumpFormat := dfCompressedArchive;
  FPSQLDump.CompressLevel := 9;
  FPSQLDump.RewriteFile := True;
  TestDumpToFile();
end;

procedure TestTPSQLDump.TestDumpDirectory;
begin
  DumpFileName := 'TestDumpToFile';
  FPSQLDump.DumpFormat := dfDirectory;
  FPSQLDump.RewriteFile := True;
  TestDumpToFile();
end;

procedure TestTPSQLDump.TestDumpPlain;
begin
  DumpFileName := 'TestDumpToFile.sql';
  FPSQLDump.DumpFormat := dfPlain;
  FPSQLDump.CompressLevel := 0;
  FPSQLDump.RewriteFile := True;
  TestDumpToFile();
end;

procedure TestTPSQLDump.TestDumpPlainCompressed;
begin
  DumpFileName := 'TestDumpToFile.gz';
  FPSQLDump.DumpFormat := dfPlain;
  FPSQLDump.CompressLevel := 6;
  FPSQLDump.RewriteFile := True;
  TestDumpToFile();
end;

procedure TestTPSQLDump.TestDumpTar;
begin
  DumpFileName := 'TestDumpToFile.tar';
  FPSQLDump.DumpFormat := dfTarArchive;
  FPSQLDump.CompressLevel := 0;
  FPSQLDump.RewriteFile := True;
  TestDumpToFile();
end;

procedure TestTPSQLDump.TestDumpToFile;
var
  Log: TStrings;
begin
  Log := TStringList.Create;
  try
    FPSQLDump.DumpToFile(DumpFileName, Log);
    Check(FileExists(DumpFileName), 'Dump file empty');
    Check(Log.Count > 0, 'Dump log empty');
  finally
    Log.Free;
  end;
end;

procedure TestTPSQLDump.TestDumpToFile1;
var
  LogFileName: string;
begin
  LogFileName := 'TestDumpToFile1.log';
  try
    FPSQLDump.DumpToFile(DumpFileName, LogFileName);
    Check(FileExists(DumpFileName), 'Dump file empty');
    Check(FileExists(LogFileName), 'Log file empty');
  finally
    SysUtils.DeleteFile(LogFileName);
  end;
end;

procedure TestTPSQLRestore.SetUp;
begin
  FPSQLRestore := TPSQLRestore.Create(nil);
end;

procedure TestTPSQLRestore.TearDown;
begin
  FPSQLRestore.Free;
  FPSQLRestore := nil;
end;

procedure TestTPSQLRestore.TestRestoreFromFile;
var
  Log: TStrings;
  FileName: string;
begin
  // TODO: Setup method call parameters
  FPSQLRestore.RestoreFromFile(FileName, Log);
  // TODO: Validate method results
end;

procedure TestTPSQLRestore.TestRestoreFromFile1;
var
  LogFileName: string;
  FileName: string;
begin
  // TODO: Setup method call parameters
  FPSQLRestore.RestoreFromFile(FileName, LogFileName);
  // TODO: Validate method results
end;

{ TDbSetup }

procedure TDbSetup.SetUp;
begin
  inherited;
  SetUpTestDatabase(QryDB, 'PSQLDump.conf');
end;

procedure TDbSetup.TearDown;
begin
  inherited;
  ComponentToFile(QryDB, 'PSQLDump.conf');
  QryDB.Free;
end;

initialization
  //PaGo: Register any test cases with setup decorator
  RegisterTest(TDbSetup.Create(TestTPSQLDump.Suite, 'Database Setup'));
  RegisterTest(TDbSetup.Create(TestTPSQLRestore.Suite, 'Database Setup'));

end.

