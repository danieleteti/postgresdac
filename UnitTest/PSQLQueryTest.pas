unit PSQLQueryTest;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Db, Windows, PSQLAccess, ExtCtrls, Controls, Classes, PSQLDbTables,
  PSQLTypes, SysUtils, DbCommon, Variants, Graphics, StdVCL, TestExtensions,
  Forms, PSQLConnFrm;

type
  //Setup decorator
  TDbSetup = class(TTestSetup)
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  end;

  // Test methods for class TPSQLQuery
  TestTPSQLQuery = class(TTestCase)
  strict private
    FPSQLQuery: TPSQLQuery;

  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
  //dataset options
    procedure TestEmptyCharAsNullOption;
  //TField.AsXXX
    procedure TestAsInteger;
    procedure TestAsFloat;
    procedure TestAsString;
    procedure TestAsBoolean;
    procedure TestAsTime;
    procedure TestAsDate;
    procedure TestAsTimestamp;
  //RequestLive modifications
    procedure TestInsert;
    procedure TestUpdate;
    procedure TestDelete;
  //bookmarks
    procedure TestBookmarks;
  //locate
    procedure TestLocateStr;
    procedure TestLocateInt;
  //TFieldDef properties populated
    procedure TestRequired;
  //date and time checks
    procedure TestTimeValues;
    procedure TestDateValues;
    procedure TestTimestampValues;
  end;

var
  QryDB: TPSQLDatabase;

implementation

uses TestHelper, DateUtils;

procedure TestTPSQLQuery.SetUp;
begin
  FPSQLQuery := TPSQLQuery.Create(nil);
  FPSQLQuery.Database := QryDB;
  FPSQLQuery.ParamCheck := False;
end;

procedure TestTPSQLQuery.TearDown;
begin
  FPSQLQuery.Free;
  FPSQLQuery := nil;
end;

procedure TestTPSQLQuery.TestAsBoolean;
begin
 FPSQLQuery.SQL.Text := 'SELECT True, False';
 FPSQLQuery.Open;
 Check(FPSQLQuery.Fields[0].AsBoolean and not FPSQLQuery.Fields[1].AsBoolean, 'Field value AsBoolean is incorrect');
 FPSQLQuery.Close;
end;

procedure TestTPSQLQuery.TestAsDate;
begin
 FPSQLQuery.SQL.Text := 'SELECT current_date';
 FPSQLQuery.Open;
 Check(IsToday(FPSQLQuery.Fields[0].AsDateTime), 'Field value AsDate is incorrect');
 FPSQLQuery.Close
end;

procedure TestTPSQLQuery.TestAsFloat;
const D: Double = 12.8;
begin
 FPSQLQuery.SQL.Text := 'SELECT 12.8';
 FPSQLQuery.Open;
 Check(FPSQLQuery.Fields[0].AsFloat = D, 'Field value AsFloat is incorrect');
 FPSQLQuery.Close;
end;

procedure TestTPSQLQuery.TestAsInteger;
begin
 FPSQLQuery.SQL.Text := 'SELECT 12345';
 FPSQLQuery.Open;
 Check(FPSQLQuery.Fields[0].AsInteger = 12345, 'Field value AsInteger is incorrect');
 FPSQLQuery.Close;
end;

procedure TestTPSQLQuery.TestAsString;
begin
 FPSQLQuery.SQL.Text := 'SELECT ''foo''::varchar(30)';
 FPSQLQuery.Open;
 Check(FPSQLQuery.Fields[0].AsString = 'foo', 'Field value AsString is incorrect');
 FPSQLQuery.Close;
end;

procedure TestTPSQLQuery.TestAsTime;
var ClientTime, ServerTime: TTime;
begin
 FPSQLQuery.SQL.Text := 'SELECT LOCALTIME';
 FPSQLQuery.Open;
 ClientTime := Time();
 ServerTime := TimeOf(FPSQLQuery.Fields[0].AsDateTime);
 Check(MinutesBetween(ClientTime, ServerTime) < 1, 'Field value AsTime is incorrect');
 FPSQLQuery.Close
end;

procedure TestTPSQLQuery.TestAsTimestamp;
begin
 FPSQLQuery.SQL.Text := 'SELECT LOCALTIMESTAMP';
 FPSQLQuery.Open;
 Check(MinutesBetween(Now(), FPSQLQuery.Fields[0].AsDateTime) < 1, 'Field value AsTimestamp is incorrect');
 FPSQLQuery.Close
end;

procedure TestTPSQLQuery.TestBookmarks;
var
   B: TBookmark;
   BookmarkedPos: longint;
begin
  FPSQLQuery.SQL.Text := 'SELECT * FROM generate_series(1, 10)';
  FPSQLQuery.Open;
  FPSQLQuery.MoveBy(5);
  B := FPSQLQuery.GetBookmark;
  BookmarkedPos := FPSQLQuery.RecNo;
  FPSQLQuery.First;
  FPSQLQuery.GotoBookmark(B);
  Check(FPSQLQuery.RecNo = BookmarkedPos, 'GotoBookmark failed');
  Check(FPSQLQuery.BookmarkValid(B), 'BookmarkValid failed');
end;

procedure TestTPSQLQuery.TestDateValues;
  procedure CheckTime(ATime: TDateTime);
  begin
    FPSQLQuery.Edit;
    FPSQLQuery.FieldByName('intf').AsInteger := Random(MaxInt); //not null field
    FPSQLQuery.FieldByName('datef').AsDateTime := ATime;
    FPSQLQuery.Post;
    Check(FPSQLQuery.FieldByName('datef').AsDateTime = ATime, 'Cannot set DATE field to ' + DateTimeToStr(ATime));
  end;
begin
  FPSQLQuery.SQL.Text := 'SELECT * FROM requestlive_test';
  FPSQLQuery.RequestLive := True;
  FPSQLQuery.Open;
  CheckTime(EncodeDate(1899, 12, 30));
  CheckTime(Today());
  CheckTime(EncodeDate(1623, 6, 19)); //Blaise Pascal was born this day
end;

procedure TestTPSQLQuery.TestDelete;
begin
  FPSQLQuery.SQL.Text := 'SELECT * FROM requestlive_test';
  FPSQLQuery.RequestLive := True;
  FPSQLQuery.Open;
  FPSQLQuery.Delete;
  Check(FPSQLQuery.RecordCount = 0, 'TPSQLQuery.Delete failed');
end;

procedure TestTPSQLQuery.TestEmptyCharAsNullOption;
begin
  FPSQLQuery.Options := [];
  FPSQLQuery.SQL.Text := 'SELECT ''''::varchar(30), ''text''::varchar(30) as col1';
  FPSQLQuery.Open;
  Check(not FPSQLQuery.Fields[0].IsNull, 'Field must be NOT NULL due to normal options');
  FPSQLQuery.Close;

  FPSQLQuery.Options := [dsoEmptyCharAsNull];
  FPSQLQuery.SQL.Text := 'SELECT ''''::varchar(30), ''text''::varchar(30) as col1';
  FPSQLQuery.Open;
  Check(FPSQLQuery.Fields[0].IsNull, 'IsNULL must be true due to dsoEmptyCharAsNull used');
  Check(FPSQLQuery.Fields.FieldByName('col1').AsWideString = 'text', 'Field must be not empty if dsoEmptyCharAsNull enabled');
  FPSQLQuery.Close;
end;

procedure TestTPSQLQuery.TestInsert;
begin
  FPSQLQuery.SQL.Text := 'SELECT * FROM requestlive_test';
  FPSQLQuery.RequestLive := True;
  FPSQLQuery.Open;
  FPSQLQuery.Insert;
  FPSQLQuery.FieldByName('intf').AsInteger := Random(MaxInt);
  FPSQLQuery.FieldByName('string').AsString := 'test test';
  FPSQLQuery.FieldByName('datum').AsDateTime := Now();
  FPSQLQuery.FieldByName('b').AsBoolean := Boolean(Random(1));
  FPSQLQuery.FieldByName('floatf').AsFloat := Random();
  FPSQLQuery.Post;
  Check(FPSQLQuery.RecordCount = 1, 'TPSQLQuery.Insert failed');
end;

procedure TestTPSQLQuery.TestLocateInt;
begin
  FPSQLQuery.SQL.Text := 'SELECT col1 FROM generate_series(11, 16) AS c(col1)';
  FPSQLQuery.Open;
  Check(FPSQLQuery.Locate('col1', '12', []), 'Locate failed with default options');
  Check(FPSQLQuery.RecNo = 2, 'Locate positioning failed with default options');

  Check(FPSQLQuery.Locate('col1', '13', [loPartialKey]), 'Locate failed with loPartialKey option');
  Check(FPSQLQuery.RecNo = 3, 'Locate positioning failed with loPartialKey option');

  Check(FPSQLQuery.Locate('col1', '14', [loCaseInsensitive]), 'Locate failed with loCaseInsensitive option');
  Check(FPSQLQuery.RecNo = 4, 'Locate positioning failed with loCaseInsensitive option');

  Check(FPSQLQuery.Locate('col1', '15', [loCaseInsensitive, loPartialKey]), 'Locate failed with full options');
  Check(FPSQLQuery.RecNo = 5, 'Locate positioning failed with full options');
end;

procedure TestTPSQLQuery.TestLocateStr;
begin
  FPSQLQuery.SQL.Text := 'SELECT col1, cash_words(col1::money)::varchar(50) AS col2 FROM generate_series(1, 6) AS g(col1)';
  FPSQLQuery.Open;
//single column
  Check(FPSQLQuery.Locate('col2', 'Two dollars and zero cents', []) and (FPSQLQuery.RecNo = 2),
          'Locate failed with default options');
  Check(FPSQLQuery.Locate('col2', 'Thr', [loPartialKey]) and (FPSQLQuery.RecNo = 3),
          'Locate failed with loPartialKey option');
  Check(FPSQLQuery.Locate('col2', 'FiV', [loCaseInsensitive, loPartialKey]) and (FPSQLQuery.RecNo = 5),
          'Locate failed with full options');
//multicolumn
  Check(FPSQLQuery.Locate('col1;col2', VarArrayOf([2, 'Two dollars and zero cents']), []) and (FPSQLQuery.RecNo = 2),
          'Multicolumn Locate failed with default options');
  Check(FPSQLQuery.Locate('col1;col2', VarArrayOf([3, 'Thr']), [loPartialKey]) and (FPSQLQuery.RecNo = 3),
          'Multicolumn Locate failed with loPartialKey option');
  Check(FPSQLQuery.Locate('col1;col2', VarArrayOf([5, 'FiV']), [loCaseInsensitive, loPartialKey]) and (FPSQLQuery.RecNo = 5),
          'Multicolumn Locate failed with full options');
end;

procedure TestTPSQLQuery.TestRequired;
begin
  FPSQLQuery.SQL.Text := 'SELECT * FROM requestlive_test'; //single table query
  FPSQLQuery.RequestLive := True;
  FPSQLQuery.Open;
  Check(not FPSQLQuery.FieldDefs[0].Required, 'SERIAL should be not Required field');
  Check(FPSQLQuery.FieldDefs[1].Required, 'NOT NULL should be Required field');
  Check(not FPSQLQuery.FieldDefs[2].Required, 'NOT NULL + DEFAULT should be not Required field');
  Check(not FPSQLQuery.FieldDefs[3].Required, 'Simple definition should be not Required field');    
  Check(not FPSQLQuery.FieldDefs[4].Required, 'Simple definition should be not Required field'); 
  FPSQLQuery.Close;
  FPSQLQuery.SQL.Text := 'SELECT r1.id, r1.intf, r1.string, r1.datum, ' +
                         'r2.id, r2.intf, r2.string, r2.datum ' +
                         'FROM requestlive_test r1, required_test r2'; //multi table query
  FPSQLQuery.RequestLive := True;
  FPSQLQuery.Open;
  Check(not FPSQLQuery.FieldDefs[0].Required, 'SERIAL should be not Required field');
  Check(FPSQLQuery.FieldDefs[1].Required, 'NOT NULL should be Required field');
  Check(not FPSQLQuery.FieldDefs[2].Required, 'NOT NULL + DEFAULT should be not Required field');
  Check(not FPSQLQuery.FieldDefs[3].Required, 'Simple definition should be not Required field');    
  Check(not FPSQLQuery.FieldDefs[4+0].Required, 'SERIAL should be not Required field');
  Check(FPSQLQuery.FieldDefs[4+1].Required, 'NOT NULL should be Required field');
  Check(not FPSQLQuery.FieldDefs[4+2].Required, 'NOT NULL + DEFAULT should be not Required field');
  Check(not FPSQLQuery.FieldDefs[4+3].Required, 'Simple definition should be not Required field');    
  FPSQLQuery.Close;
   
end;

procedure TestTPSQLQuery.TestTimestampValues;
  procedure CheckTimestamp(ATime: TDateTime);
  begin
    FPSQLQuery.Edit;
    FPSQLQuery.FieldByName('intf').AsInteger := Random(MaxInt); //not null field
    FPSQLQuery.FieldByName('datum').AsDateTime := ATime;
    FPSQLQuery.Post;
    Check(FPSQLQuery.FieldByName('datum').AsDateTime = ATime, 'Cannot set TIMESTAMP field to ' + DateTimeToStr(ATime));
  end;
begin
  FPSQLQuery.SQL.Text := 'SELECT * FROM requestlive_test';
  FPSQLQuery.RequestLive := True;
  FPSQLQuery.Open;
  CheckTimestamp(Yesterday() + EncodeTime(0, 0, 0, 0));
  CheckTimestamp(Tomorrow() + EncodeTime(12, 0, 0, 0));
  CheckTimestamp(EncodeDate(1899, 12, 30) + EncodeTime(0, 0, 0, 0));
  CheckTimestamp(EncodeDate(1899, 12, 30) + EncodeTime(0, 0, 0, 100));
  CheckTimestamp(EncodeDate(1899, 12, 30) + EncodeTime(0, 0, 0, 1));
  CheckTimestamp(EncodeDate(1899, 12, 30) + EncodeTime(23, 59, 59, 999));
  CheckTimestamp(EncodeDateTime(1623, 6, 19, 12, 00, 00, 20)); //Blaise Pascal was born this day
end;

procedure TestTPSQLQuery.TestTimeValues;
  procedure CheckTime(ATime: TDateTime);
  begin
    FPSQLQuery.Edit;
    FPSQLQuery.FieldByName('intf').AsInteger := Random(MaxInt); //not null field
    FPSQLQuery.FieldByName('timef').AsDateTime := ATime;
    FPSQLQuery.Post;
    Check(FPSQLQuery.FieldByName('timef').AsDateTime = ATime, 'Cannot set TIME field to ' + DateTimeToStr(ATime));
  end;
begin
  FPSQLQuery.SQL.Text := 'SELECT * FROM requestlive_test';
  FPSQLQuery.RequestLive := True;
  FPSQLQuery.Open;
  CheckTime(EncodeTime(0, 0, 0, 0));
  CheckTime(EncodeTime(0, 0, 0, 1));
  CheckTime(EncodeTime(0, 0, 0, 100));
  CheckTime(EncodeTime(23, 59, 59, 999));
end;

procedure TestTPSQLQuery.TestUpdate;
begin
  FPSQLQuery.SQL.Text := 'SELECT * FROM requestlive_test';
  FPSQLQuery.RequestLive := True;
  FPSQLQuery.Open;
  FPSQLQuery.Edit;
  FPSQLQuery.FieldByName('intf').AsInteger := Random(MaxInt);
  FPSQLQuery.FieldByName('string').AsString := 'test test updated';
  FPSQLQuery.FieldByName('datum').AsDateTime := Now();
  FPSQLQuery.FieldByName('b').AsBoolean := Boolean(Random(1));
  FPSQLQuery.FieldByName('floatf').AsFloat := Random();
  FPSQLQuery.Post;
  Check(FPSQLQuery.FieldByName('string').AsString = 'test test updated', 'TPSQLQuery.Edit failed');
end;

{ TDbSetup }

procedure TDbSetup.SetUp;
begin
  inherited;
  SetUpTestDatabase(QryDB, 'PSQLQueryTest.conf');
  QryDB.Execute('CREATE TABLE IF NOT EXISTS requestlive_test ' +
                '(' +
                '  id serial NOT NULL PRIMARY KEY,' + //Serial will create Sequence -> not Required
                '  intf integer NOT NULL,' + //NotNull ->Required
                '  string character varying(100) NOT NULL DEFAULT ''abc'',' + //NotNull + Default -> not Required
                '  datum timestamp without time zone,' + //not Required etc.
                '  notes text,' +
                '  graphic oid,' +
                '  b_graphic bytea,' +
                '  b boolean,' +
                '  floatf real,' +
                '  datef date,' +
                '  timef time' +
                ')');
  QryDB.Execute('CREATE TABLE IF NOT EXISTS required_test ' +
                '(' +
                '  id serial NOT NULL PRIMARY KEY,' + //Serial will create Sequence -> not Required
                '  intf integer NOT NULL,' + //NotNull ->Required
                '  string character varying(100) NOT NULL DEFAULT ''abc'',' + //NotNull + Default -> not Required
                '  datum timestamp without time zone)'); //not Required.  
end;

procedure TDbSetup.TearDown;
begin
  inherited;
  QryDB.Execute('DROP TABLE requestlive_test');
  QryDB.Close;
  ComponentToFile(QryDB, 'PSQLQueryTest.conf');
  QryDB.Free;
end;

initialization
  //PaGo: Register any test cases with setup decorator
  RegisterTest(TDbSetup.Create(TestTPSQLQuery.Suite, 'Database Setup'));

end.

